---
title: Event Listeners for Blueprints and AVS
---

## Event Listeners for Blueprints and AVS
The SDK supports a variety of event listeners out of the box for creating jobs, slashing reports, and hooks useful for developing complex multi-party services. These include EVM contract listeners and periodic and time-based listeners.

Developers can also build their own custom event listeners to trigger jobs and reports.

### EVM Contract Listeners
You can specify a custom EVM event listener for the job, which is particularly needed when building an AVS on Eigenlayer. 
```rust
#[derive(AlloyContractEventListener)]
struct CustomContractListener {
    instance: <custom_contract_instance>,
    event: <custom_contract_event>,
    event_converter: convert_event_to_inputs,
    callback: <custom_contract_callback_type>,
}

#[job(
    id = <job_id>,
    params(<param_list>),
    result(<result_type>),
    event_listener(CustomContractListener),
)]
pub fn job_name(<parameters>) -> Result<<return_type>, <error_type>> {
    // Job implementation
}
```

EVM contract listeners can also be implemented with an additional layer of middleware known by implementing the `LayeredMiddleware` trait. This consume the event listener and adds an additional opportunity to process the data in more complex and custom ways, such as calling an external API or computing over the event.


### Layered Middleware for EVM Contract Listeners

Layered middleware can be used with EVM contract listeners to add complex processing logic, such as interacting with external APIs or performing AI-based decision making. Here's an example of how to implement a layered middleware for an EVM contract event:

**Gas Price Middleware**: Implement a filter for preventing job execution when gas prices exceed some threshold.
```rust
// Define a custom EVM contract listener
#[derive(AlloyContractEventListener)]
struct CustomEVMListener {
    instance: ContractInstance,
    event: ContractEvent,
    event_converter: EventConverter,
    callback: ContractCallback,
}

// Define a custom middleware for gas price checking
struct GasPriceMiddleware;

impl ListenerMiddleware for GasPriceMiddleware {
    /// Handles the EVM contract event by checking the current gas price.
    ///
    /// This middleware implementation makes an API call to an Ethereum gas price oracle,
    /// checks if the gas price exceeds a certain threshold, and determines if the job
    /// should be triggered.
    ///
    /// # Arguments
    ///
    /// event - A vector of bytes representing the event data from the EVM contract.
    ///
    /// # Returns
    ///
    /// Ok(()) if the gas price exceeds the threshold (e.g., 100 Gwei).
    /// Err(Error::GasPriceThresholdNotMet) if the gas price is below the threshold.
    ///
    /// # Errors
    ///
    /// This function can return errors if:
    /// - API call to the gas price oracle fails
    /// - JSON parsing of the API response fails
    /// - Conversion of gas price to Gwei fails
    fn on_event(&self, event: Vec<u8>) -> Result<(), Error> {
        // Make API call to Ethereum gas price oracle
        let client = reqwest::blocking::Client::new();
        let gas_price_url = "https://api.etherscan.io/api?module=gastracker&action=gasoracle&apikey=YourApiKeyToken";
        let response: Value = client.get(gas_price_url)
            .send()?
            .json()?;
        // Extract the "ProposeGasPrice" (in Gwei)
        let gas_price_gwei: u64 = response["result"]["ProposeGasPrice"]
            .as_str()
            .unwrap()
            .parse()
            .unwrap();
        println!("Current gas price: {} Gwei", gas_price_gwei);
        // Check if gas price exceeds threshold (e.g., 100 Gwei)
        if gas_price_gwei > 100 {
            println!("Gas price exceeds threshold. Triggering job.");
            Ok(())
        } else {
            println!("Gas price below threshold. Not triggering job.");
            Err(Error::GasPriceThresholdNotMet)
        }
    }
}

// Define the job using the custom EVM listener with gas price middleware
#[job(
    id = "high_gas_price_job",
    params(threshold: u64),
    result(bool),
    event_listener(CustomEVMListener, middleware = GasPriceMiddleware),
)]
pub fn monitor_gas_price(threshold: u64) -> Result<bool, Error> {
    // Job implementation
    println!("High gas price detected! Current threshold: {} Gwei", threshold);
    // Perform actions based on high gas price...
    Ok(true)
}

**AI Smart Execution**: Implement a middleware that decides whether to execute the job or not based on the event metadata.
```rust
use alloy_primitives::Address;
use ethers::prelude::*;
use reqwest;
use serde_json::json;

// Define a custom EVM contract listener
#[derive(AlloyContractEventListener)]
struct AiFilterContractListener {
    instance: ContractInstance,
    event: ContractEvent,
    event_converter: EventConverter,
    callback: ContractCallback,
    huggingface_api_token: String,
    model_endpoint: String,
}

impl AiFilterContractListener {
    async fn query_llama_model(&self, event_data: &str) -> Result<bool, Error> {
        let client = reqwest::Client::new();
        let prompt = format!("Given the event data {}, should we execute the compute task or is it spam? Respond only with `'yes, execute`' or `'no`'", event_data);

        let response = client.post(&self.model_endpoint)
            .header("Authorization", format!("Bearer {}", self.huggingface_api_token))
            .json(&json!({
                "inputs": prompt,
                "parameters": {
                    "max_new_tokens": 50,
                    "temperature": 0.7,
                    "top_p": 0.95,
                    "do_sample": true
                }
            }))
            .send()
            .await?;

        let result: serde_json::Value = response.json().await?;
        let generated_text = result[0]["generated_text"].as_str().unwrap_or("");

        // Check if the generated text contains "yes, execute"
        if generated_text.to_lowercase().contains("yes, execute") {
            Ok(true)
        } else {
            Ok(false)
        }
    }
}

impl ListenerMiddleware for AiFilterContractListener {
    /// Handles the EVM contract event by checking if it's spam using a LLama model.
    ///
    /// This middleware implementation sends the event data to a LLama model hosted on
    /// Hugging Face to determine if the event should be processed or ignored as spam.
    ///
    /// # Arguments
    ///
    /// * `event` - A vector of bytes representing the event data from the EVM contract.
    ///
    /// # Returns
    ///
    /// * `Ok(())` if the model determines the event is not spam.
    /// * `Err(Error::SpamDetected)` if the model determines the event is spam.
    ///
    /// # Errors
    ///
    /// This function can return errors if:
    /// - API call to Hugging Face fails
    /// - JSON parsing of the API response fails
    async fn on_event(&self, event: Vec<u8>) -> Result<(), Error> {
        let event_data = hex::encode(&event);
        let is_valid = self.query_llama_model(&event_data).await?;

        if is_valid {
            println!("Event passed spam check. Proceeding with job execution.");
            Ok(())
        } else {
            println!("Event failed spam check. Aborting job execution.");
            Err(Error::SpamDetected)
        }
    }
}

// Define the job using the custom EVM listener with AI spam detection middleware
#[job(
    id = <job_id>
    params(<param_types>),
    result(<result_type>),
    event_listener(AiFilterContractListener),
)]
pub fn job_name(<parameters>) -> Result<<return_type>, <error_type>> {
    // Job implementation
}
```


### Periodic listeners

Periodic listeners are event listeners that trigger at specific time intervals. They are useful for tasks that need to be executed regularly, such as quality of service metrics/uptime checkers, data updates, and subscription style services.

To use a periodic listener, you can use the `PeriodicListener` struct provided by the SDK. Here's an example of how to define a job with a periodic listener:

```rust
#[job(
    id = <job_id>,
    params(<param_list>),
    result(<result_type>),
    event_listener(OneMinutePeriodicListener),
)]
pub fn job_name(<parameters>) -> Result<<return_type>, <error_type>> {
    // Job implementation
}
```

Periodic listeners can also be implemented with the `LayeredMiddleware` abstraction. A developer might use this to check whether a smart contract value has changed or if a offchain data source has updated to a new desirable state for processing.

```rust
#[derive(PeriodicListener)]
struct CustomPeriodicListener {
    interval: Duration,
}

impl ListenerMiddleware for CustomPeriodicListener {
    /// Handles the periodic event by checking the Bitcoin price change over the last hour.
    ///
    /// This middleware implementation makes API calls to Coinbase to fetch the current and historical
    /// Bitcoin prices, calculates the percentage change, and determines if a significant price drop
    /// has occurred.
    ///
    /// # Arguments
    ///
    /// * `event` - A vector of bytes representing the event data (unused in this implementation).
    ///
    /// # Returns
    ///
    /// * `Ok(())` if the Bitcoin price has dropped by 10% or more in the last hour.
    /// * `Err(Error::PriceChangeThresholdNotMet)` if the price drop is less than 10%.
    ///
    /// # Errors
    ///
    /// This function can return errors if:
    /// - API calls to Coinbase fail
    /// - JSON parsing of the API responses fails
    /// - String parsing of price values fails
    ///
    /// # Example
    ///
    /// ```rust
    /// let listener = CustomPeriodicListener::new();
    /// match listener.on_event(vec![]) {
    ///     Ok(_) => println!("Significant price drop detected!"),
    ///     Err(e) => println!("No significant price change or error: {:?}", e),
    /// }
    /// ```
    fn on_event(event: Vec<u8>) -> Result<(), Error> {
        // Import necessary crates
        use reqwest;
        use serde_json::Value;
        use chrono::{Utc, Duration};

        // Make API call to Coinbase API
        let client = reqwest::blocking::Client::new();
        let now = Utc::now();
        let one_hour_ago = now - Duration::hours(1);

        let current_price_url = "https://api.coinbase.com/v2/prices/BTC-USD/spot";
        let historical_price_url = format!("https://api.coinbase.com/v2/prices/BTC-USD/spot?date={}", one_hour_ago.to_rfc3339());

        let current_price_response: Value = client.get(current_price_url)
            .send()?
            .json()?;
        let historical_price_response: Value = client.get(&historical_price_url)
            .send()?
            .json()?;

        let current_price: f64 = current_price_response["data"]["amount"].as_str().unwrap().parse().unwrap();
        let historical_price: f64 = historical_price_response["data"]["amount"].as_str().unwrap().parse().unwrap();

        // Calculate price change percentage
        let price_change_percentage = (current_price - historical_price) / historical_price * 100.0;

        // Check if price has dropped by 10% or more
        if price_change_percentage <= -10.0 {
            println!("BTC price has dropped by {:.2}% in the last hour", price_change_percentage.abs());
            // Trigger the job or perform any other action
            Ok(())
        } else {
            println!("BTC price change in the last hour: {:.2}%", price_change_percentage);
            Err(Error::PriceChangeThresholdNotMet)
        }
    }
}

#[job(
    id = <job_id>,
    params(<param_list>),
    result(<result_type>),
    event_listener(CustomPeriodicListener),
)]
pub fn job_name(<parameters>) -> Result<<return_type>, <error_type>> {
    // Job implementation
}
```